# label to the external code generated by the kernel main function
.extern kernel_main

# Higher half staring address
.set HIGHER_HALF_ADDR, 0xE0000000
.set HIGHER_HALF_PAGE_TABLE_INDEX, 896 # = (HIGH_HALF_ADDR / 4.0 Gib) * 1024

# Declare constants for the multiboot header.
.set ALIGN,    1<<0             # align loaded modules on page boundaries
.set MEMINFO,  1<<1             # provide memory map
.set FLAGS,    ALIGN | MEMINFO  # this is the Multiboot 'flag' field
.set MAGIC,    0x1BADB002       # 'magic number' lets bootloader find the header
.set CHECKSUM, -(MAGIC + FLAGS) # checksum of above, to prove we are multiboot

# Declare a multiboot header that marks the program as a kernel.
.section .multiboot.data, "aw"
    .align 4
    .long MAGIC
    .long FLAGS
    .long CHECKSUM

# Allocate the initial stack 16 KiB stack
.section .bootstrap_stack, "aw", @nobits
    stack_bottom:
    .skip 16384
    stack_top:

# Preallocate page tables. Placed BSS section since we what the page tables to be initialised to 0
.section .bss, "aw", @nobits
	.align 4096 # 4096 Aligend since 12 lsb is used for flags 
boot_page_directory:
	.skip 4096 # One directory fits 1024 (32 bit) entries
boot_page_table1:
	.skip 4096 # One table fits 1024 (32 bit) entries, i.e. can map 1024 * 4K pages = 4 Mib
# Note, Further page tables may be required if the kernel grows beyond 3 MiB.


# Intitial kernel boot code, contained in multiboot section.
# Serves the purpose of setting up the initial paging before entering higher half
.section .multiboot.text, "a"
.global _start
.type _start, @function
_start:
    # Physical address of boot_page_table1.
	# TODO: I recall seeing some assembly that used a macro to do the
	#       conversions to and from physical. Maybe this should be done in this
	#       code as well?
	movl $(boot_page_table1 - HIGHER_HALF_ADDR), %edi
	
    # First physical address to map is address 0.
	# TODO: Start at the first kernel page instead. Alternatively map the first
	#       1 MiB as it can be generally useful, and there's no need to
	#       specially map the VGA buffer.	
    movl $0, %esi

    # Page table setup loop	
table_loop:
    # Skip pages before multiboot (i.e. < 1 MiB section)
    cmpl $_kernel_start, %esi
	jl skip
	
    # Once the full kernel is mapped, exit loop
    cmpl $(_kernel_end - HIGHER_HALF_ADDR), %esi
	jge end

	# Map physical address with correct permissions
	cmpl $(_wdata_start - HIGHER_HALF_ADDR), %esi
	jl default
	cmpl $(_wdata_end - HIGHER_HALF_ADDR), %esi
	jg default

	# If within writeable are map to "present, writeble"
	movl %esi, %edx
	orl $0x003, %edx
	movl %edx, (%edi)	
	jmp skip

default:	
	# Else in read-only are  "present, readable"
	movl %esi, %edx
	orl $0x001, %edx
	movl %edx, (%edi)	

skip:
	addl $4096, %esi # Increment page address by 4 KiB page size
	addl $4, %edi    # Increment page table address by 4B (each entry is 32 bits)
	loop table_loop
   
end:
	# Map VGA video memory to 0xC03FF000 as "present, writable".
	movl $(0x000B8000 | 0x003), boot_page_table1 - HIGHER_HALF_ADDR + 1023 * 4

	# The page table is used at both page directory entry 0 (virtually from 0x0
	# to 0x3FFFFF) (thus identity mapping the kernel) and page directory entry
	# 896 (virtually from 0xE0000000 to 0xE03FFFFF) (thus mapping it in the
	# higher half). The kernel is identity mapped because enabling paging does
	# not change the next instruction, which continues to be physical. The CPU
	# would instead page fault if there was no identity mapping.

	# Map the page table to both virtual addresses 0x00000000 and 0xE0000000.
	movl $(boot_page_table1 - HIGHER_HALF_ADDR + 0x003), boot_page_directory - HIGHER_HALF_ADDR + 0
	movl $(boot_page_table1 - HIGHER_HALF_ADDR + 0x003), boot_page_directory - HIGHER_HALF_ADDR + HIGHER_HALF_PAGE_TABLE_INDEX * 4

	# Set cr3 to the address of the boot_page_directory.
	movl $(boot_page_directory - HIGHER_HALF_ADDR), %ecx
	movl %ecx, %cr3

	# Enable paging and the write-protect bit.
	movl %cr0, %ecx
	orl $0x80010000, %ecx
	movl %ecx, %cr0

	# Jump to higher half with an absolute jump. 
	lea kernel_start, %ecx
	jmp *%ecx


# Setup and launch kernel C code
.section .text
kernel_start:
    # At this point, paging is fully set up and enabled.

	# Unmap the identity mapping as it is now unnecessary. 
	movl $0, boot_page_directory + 0

	# Reload cr3 to force a TLB flush so the changes to take effect.
	movl %cr3, %ecx
	movl %ecx, %cr3

    # sets correct stack pointer (x86 stack grows downward)
    mov $stack_top, %esp

    # Call the global constructojrs.
    call _init

    # calls the kernel main function
    call kernel_main

    # If, by some mysterious circumstances, the kernel's C code ever returns, all we want to do is to hang the CPU
    hang:
        cli         # disable interrupts
        hlt         # halt cpu
        jmp hang    # retry on failure
             